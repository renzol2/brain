{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/docs/rust","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"computer-science programming-languages rust\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"rust\"\n  }, \"Rust\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#rust\"\n  }, \"Rust\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#types\"\n  }, \"Types\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#standard-library-std\"\n  }, \"Standard library (\", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"std\"), \")\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#variables\"\n  }, \"Variables\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#associated-functions\"\n  }, \"Associated Functions\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#references\"\n  }, \"References\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#enums\"\n  }, \"Enums\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#match-expression\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"match\"), \" expression\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#sources\"\n  }, \"Sources\"))))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Rust\"), \" is a programming language focused on delivering high performance with low-level access alongside an improved developer experience compared to existing low-level languages like C and C++.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"runs very fast\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"prevents memory leaks and segmentation faults\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"guarantees thread safety\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"stresses performance and correctness\")), mdx(\"p\", null, \"Can be compiled down to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/WebAssembly\",\n    \"title\": \"WebAssembly\"\n  }, \"[[WebAssembly]]\"), \" for use in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/client-side-renderingorclient-side\",\n    \"title\": \"client-side-rendering|client-side\"\n  }, \"[[client-side-rendering|client-side]]\"), \" web applications.\"), mdx(\"h2\", {\n    \"id\": \"types\"\n  }, \"Types\"), mdx(\"p\", null, \"Rust has a strong, static type system. However, it also has type inference.\"), mdx(\"p\", null, \"Number types:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"i32\"), \", a 32-\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/bit\",\n    \"title\": \"bit\"\n  }, \"[[bit]]\"), \" number\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"u32\"), \", an unsigned 32-bit number\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"useful for small, positive numbers\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"i64\"), \", a 64-bit number\")), mdx(\"h2\", {\n    \"id\": \"standard-library-std\"\n  }, \"Standard library (\", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"std\"), \")\"), mdx(\"p\", null, \"Rust's standard library has many useful packages:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"std::io\"), \" (input/output)\")), mdx(\"p\", null, \"Rust imports some packages automatically into every Rust program in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"prelude\"), \".\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"kept small as possible\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"contains things used in every Rust program, like \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"traits\"))), mdx(\"h2\", {\n    \"id\": \"variables\"\n  }, \"Variables\"), mdx(\"p\", null, \"See: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/variables-rustorVariables-(Rust)\",\n    \"title\": \"variables-rust|Variables (Rust)\"\n  }, \"[[variables-rust|Variables (Rust)]]\"), \"\"), mdx(\"h2\", {\n    \"id\": \"associated-functions\"\n  }, \"Associated Functions\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"let mut guess = String::new();\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"::\"), \" syntax means that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new\"), \" is an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"associated function\"), \"\\nof the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \" type. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new\"), \" function creates a new, empty string. As a function, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new\"), \" is a common name across many types for a function that makes a new value of some kind.\"), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"reference\"), \" is a way to let multiple parts of the code access one piece of data without needing to copy that data into memory multiple times.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Rust makes it safe and easy to use references\")), mdx(\"p\", null, \"References are indicated by a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&\"), \".\"), mdx(\"h2\", {\n    \"id\": \"enums\"\n  }, \"Enums\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Enumerations\"), \", or just \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"enums\"), \", are types with a fixed set of values, called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"variants\"), \".\"), mdx(\"p\", null, \"Examples:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Result\"), \" types, with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Ok\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Err\"), \" variants\")), mdx(\"h2\", {\n    \"id\": \"match-expression\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"match\"), \" expression\"), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"match\"), \" expression is made up of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"arms\"), \".\"), mdx(\"p\", null, \"Each arm consists of a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"pattern\"), \", and the code that should be run if the value given to the beginning of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"match\"), \" expression fits that arm's pattern.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Rust takes the value given to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"match\"), \" and looks through each arm's pattern in turn\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"match\"), \" expression \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"returns\"), \" a value\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for error handling, using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"match\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"expect\"), \" is one way of moving from crashing on an error to handling the error\")), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"let guess: u32 = match guess.trim().parse() {\\n    Ok(num) => num,\\n    Err(_) => continue,\\n};\\n\")), mdx(\"h2\", {\n    \"id\": \"sources\"\n  }, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.rust-lang.org\"\n  }, \"https://www.rust-lang.org\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html\"\n  }, \"The Rust Programming Language Ch. 2: Programming a Guessing Game\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.youtube.com/watch?v=ohuTy8MmbLc\"\n  }, \"Rust in the Browser for JavaScripters: New Frontiers, New Possibilities\"))));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"computer-science web-dev javascript programming-languages\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"webassembly\"\n  }, \"WebAssembly\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"WebAssembly\"), \" (or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Wasm\"), \") is a low-level language in binary format that runs on the web with near-native performance.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for stack-based virtual machine\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"designed as a portable compilation format for several programming languages, especially low-level languages like C, C++, and \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Rust\",\n    \"title\": \"Rust\"\n  }, \"[[Rust]]\"), \"\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be run alongside \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/JavaScript\",\n    \"title\": \"JavaScript\"\n  }, \"[[JavaScript]]\"), \"\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be deployed to client or server web applications\")), mdx(\"h2\", {\n    \"id\": \"sources\"\n  }, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://webassembly.org\"\n  }, \"https://webassembly.org\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/WebAssembly\"\n  }, \"https://developer.mozilla.org/en-US/docs/WebAssembly\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"f7a5a51b-306e-5c72-80df-ddad46503baa","fields":{"slug":"/docs/webassembly","title":"WebAssembly"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"mus-407 ece-402 computer-science\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"bit\"\n  }, \"Bit\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"bit\"), \" is the most basic unit of information in the digital realm. It represents a logical state of one of two values:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"true\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"false\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"yes\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"no\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"+\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"on\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"off\"))), mdx(\"p\", null, \"\\\"Bit\\\" is a contraction of \\\"binary digit\\\"\"), mdx(\"h2\", {\n    \"id\": \"sources\"\n  }, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://en.wikipedia.org/wiki/Bit\"\n  }, \"https://en.wikipedia.org/wiki/Bit\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"730e90fa-25f8-5546-a4c2-d1bb7932da8d","fields":{"slug":"/docs/bit","title":"Bit"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": null\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"data-types-rust\"\n  }, \"Data Types (Rust)\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#data-types-rust\"\n  }, \"Data Types (Rust)\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#scalar-types\"\n  }, \"Scalar Types\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#integer-types\"\n  }, \"Integer Types\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#floating-point-types\"\n  }, \"Floating-Point Types\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#numeric-operations\"\n  }, \"Numeric Operations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#boolean-type\"\n  }, \"Boolean Type\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#character-type\"\n  }, \"Character Type\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#compound-types\"\n  }, \"Compound Types\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#tuples\"\n  }, \"Tuples\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#arrays\"\n  }, \"Arrays\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#sources\"\n  }, \"Sources\"))))), mdx(\"p\", null, \"Rust is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"statically typed\"), \", meaning the compiler must know the data type of all \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/variables-rustorvariables\",\n    \"title\": \"variables-rust|variables\"\n  }, \"[[variables-rust|variables]]\"), \" at compile time. However, the compiler can infer the type of most variables through \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"type inference\"), \".\"), mdx(\"p\", null, \"In \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Rust\",\n    \"title\": \"Rust\"\n  }, \"[[Rust]]\"), \", there are two kinds of data types: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"scalar\"), \" types and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"compound\"), \" types.\"), mdx(\"h2\", {\n    \"id\": \"scalar-types\"\n  }, \"Scalar Types\"), mdx(\"p\", null, \"A scalar type represents a single value. Rust has four primary scalar types:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/integer-types-rustorInteger-Types\",\n    \"title\": \"integer-types-rust|Integer Types\"\n  }, \"[[integer-types-rust|Integer Types]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"floating-point numbers\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Booleans\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"characters\")), mdx(\"h3\", {\n    \"id\": \"integer-types\"\n  }, \"Integer Types\"), mdx(\"p\", null, \"See: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/integer-types-rustorInteger-Types-(Rust)\",\n    \"title\": \"integer-types-rust|Integer Types (Rust)\"\n  }, \"[[integer-types-rust|Integer Types (Rust)]]\"), \"\"), mdx(\"h3\", {\n    \"id\": \"floating-point-types\"\n  }, \"Floating-Point Types\"), mdx(\"p\", null, \"Rust has two primitive types for floating point numbers (numbers with decimal points).\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"f32\"), \" (32 bits in size)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"f64\"), \" (64 bits in size)\")), mdx(\"p\", null, \"The default type is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"f64\"), \" because modern CPUs handle 64-bit floating point numbers at roughly the same speed as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"f32\"), \", but with the bonus of having more precision in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"f64\"), \".\"), mdx(\"h3\", {\n    \"id\": \"numeric-operations\"\n  }, \"Numeric Operations\"), mdx(\"p\", null, \"Rust supports basic numeric operations, including integer division:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn main() {\\n    // addition\\n    let sum = 5 + 10;\\n\\n    // subtraction\\n    let difference = 95.5 - 4.3;\\n\\n    // multiplication\\n    let product = 4 * 30;\\n\\n    // division\\n    let quotient = 56.7 / 32.2;\\n    let floored = 2 / 3; // Results in 0\\n\\n    // remainder\\n    let remainder = 43 % 5;\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"boolean-type\"\n  }, \"Boolean Type\"), mdx(\"p\", null, \"The Boolean type in Rust, specified as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bool\"), \", has two possible values: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn main() {\\n    let t = true;\\n\\n    let f: bool = false;  // with explicit type annotation\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"character-type\"\n  }, \"Character Type\"), mdx(\"p\", null, \"Rust's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"char\"), \" type is the most primitive alphabetic type.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"char\"), \" type is four \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/byte\",\n    \"title\": \"byte\"\n  }, \"[[byte]]\"), \"s in size and represents a Unicode Scalar Value, allowing for many types of characters past ASCII:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"accented letters, Chinese, Japanese, Korean, emojis, zero-width spaces\")))), mdx(\"h2\", {\n    \"id\": \"compound-types\"\n  }, \"Compound Types\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Compound types\"), \" group multiple values into one type. Rust has two primitive compound types: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"tuples\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"arrays\"), \".\"), mdx(\"h3\", {\n    \"id\": \"tuples\"\n  }, \"Tuples\"), mdx(\"p\", null, \"A tuple is a general way of grouping together a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fixed number\"), \" of values \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"of a variety of types\"), \" into one compound type.\"), mdx(\"p\", null, \"Accessing values from a tuple can be done in two ways:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"destructuring\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"period (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".\"), \") followed by index of value to access\")), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn main() {\\n    let tup: (i32, f64, u8) = (500, 6.4, 1);\\n\\n    // Destructuring\\n    let (x, y, z) = tup;\\n\\n    // Period access\\n    let five_hundred = tup.0;\\n    let six_point_four = tup.1;\\n}\\n\")), mdx(\"p\", null, \"A tuple without any values, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"()\"), \", s a special type that has only one value, also written \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"()\"), \".\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the type is called the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"unit type\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the value is called the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"unit value\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Rust expressions implicitly return the unit value if they don't return anything else\")), mdx(\"h3\", {\n    \"id\": \"arrays\"\n  }, \"Arrays\"), mdx(\"p\", null, \"Arrays are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fixed length\"), \" collections of multiple values \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"of the same type\"), \". They are single chunks of memory allocated on the stack.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn main() {\\n    let a = [1, 2, 3, 4, 5];\\n}\\n\")), mdx(\"p\", null, \"Benefits of arrays:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"useful for allocating data on the stack, rather than the heap\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"useful to ensure you always have a fixed number of identical-type elements\")), mdx(\"p\", null, \"Declaring an array's type and length explicitly:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"let a: [i32; 5] = [1, 2, 3, 4, 5];\\n\")), mdx(\"p\", null, \"Declaring an array of type and identical elements:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"// These are equivalent statements\\nlet a = [3; 5];\\nlet a = [3, 3, 3, 3, 3];\\n\")), mdx(\"p\", null, \"Array elements can be accessed by indexing using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[]\"), \" notation. If an out-of-bounds index is attempted to be accessed, the program terminates in a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"runtime\"), \" error, rather than accessing unsafe memory (i.e. unlike C or C++).\"), mdx(\"h2\", {\n    \"id\": \"sources\"\n  }, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types\"\n  }, \"https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"72f95917-8186-5d22-9763-00c419f3dbbd","fields":{"slug":"/docs/data-types-rust","title":"Data Types (Rust)"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"rust programming-languages computer-science\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, \"In \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Rust\",\n    \"title\": \"Rust\"\n  }, \"[[Rust]]\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"references\"), \" are \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/variables-rustorvariables\",\n    \"title\": \"variables-rust|variables\"\n  }, \"[[variables-rust|variables]]\"), \" that allow you to refer to some value without taking \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/ownership-rustorownership\",\n    \"title\": \"ownership-rust|ownership\"\n  }, \"[[ownership-rust|ownership]]\"), \" of it. In short:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"at any given time, you can have \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"either\"), \" one mutable reference \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"or\"), \" any number of immutable references\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"references must always be valid (no dangling references)\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn main() {\\n    let s1 = String::from(\\\"hello\\\");\\n\\n    let len = calculate_length(&s1);\\n\\n    println!(\\\"The length of '{}' is {}\\\", s1, len);\\n}\\n\\nfn calculate_length(s: &String) -> usize {\\n    s.len()\\n}\\n\")), mdx(\"p\", null, \"The diagram shows how the above code creates a reference \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&String s\"), \" pointing at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String s1\"), \":\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"561px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/brain/static/a4bffd7c3d4905fda6aed0327d142c72/bad1b/rust-references-diagram.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"42.857142857142854%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABE0lEQVQoz42R246CQBBE5/+/ywQFgSdMBOSyAnJXo4SLCnsyk5hN3GS3HmC6pru6u0Ysy/J6veZ5Xj7Q9/2v/Bsiz/MoitI05YAK1DRNbdueTqc4jrMs44AKPEJlWSqmKApyxGq12mw2tm1rmqZaced5HiGilmVxC0Px7Xbbbrfr9do0TXjXdcVut+PXNI3v+3zJ0HX9eDw6jkPNl0QYhsMwOBKEalJGEOM4PiSez6fasOs6JNC63+9JklRVdb1e4clhbELKzuczZ/HTAFV8uVwMw2Bsdtnv97RlPeUFPYMgOBwOmYT49JAkzKMD2nRgCmZWnRMJjKzrmhyx/BsU4wINWZhF/iieJd4hD8kLvZ8Kd78Bclf4nbsg85kAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Diagram of references in Rust\",\n    \"title\": \"Diagram of references in Rust\",\n    \"src\": \"/brain/static/a4bffd7c3d4905fda6aed0327d142c72/410f3/rust-references-diagram.png\",\n    \"srcSet\": [\"/brain/static/a4bffd7c3d4905fda6aed0327d142c72/0d3e1/rust-references-diagram.png 140w\", \"/brain/static/a4bffd7c3d4905fda6aed0327d142c72/6b1e2/rust-references-diagram.png 281w\", \"/brain/static/a4bffd7c3d4905fda6aed0327d142c72/410f3/rust-references-diagram.png 561w\", \"/brain/static/a4bffd7c3d4905fda6aed0327d142c72/bad1b/rust-references-diagram.png 841w\"],\n    \"sizes\": \"(max-width: 561px) 100vw, 561px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"In Rust, references are immutable by default. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Mutable references\"), \" are declared explicitly:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn main() {\\n    let mut s = String::from(\\\"hello\\\");\\n\\n    change(&mut s);\\n}\\n\\nfn change(some_string: &mut String) {\\n    some_string.push_str(\\\", world\\\");\\n}\\n\")), mdx(\"p\", null, \"Mutable references have one big restriction: you can only have one mutable reference to a particular piece of data at a time. This restriction prevents \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"data races\"), \", a race condition where\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"two or more pointers access the same data at the same time\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"at least one of the pointers is being used to write to the data\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"there's no mechanism being used to synchronize access to the data\")), mdx(\"p\", null, \"These data races cause undefined behavior and can be difficult to diagnose and fix when trying to track them down at runtime.\"), mdx(\"p\", null, \"Rust also prevents you from making \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"dangling references.\")), mdx(\"h2\", {\n    \"id\": \"sources\"\n  }, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\"\n  }, \"https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"8703e065-823a-535b-9d59-9ba8f29cc22c","fields":{"slug":"/docs/references-rust","title":"References"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"rust computer-science programming-languages\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"cargo\"\n  }, \"Cargo\"), mdx(\"p\", null, \"Cargo is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Rust\",\n    \"title\": \"Rust\"\n  }, \"[[Rust]]\"), \"'s build system and package manager.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"helps manage Rust projects by building code, downloading library dependencies, and building external libraries in packages called \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"crates\"))), mdx(\"h2\", {\n    \"id\": \"crates\"\n  }, \"Crates\"), mdx(\"p\", null, \"Crates can be classified into a few types:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"binary crate\"), \", an executable\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"library crates\"), \", which contain code intended to be used in other programs\")), mdx(\"p\", null, \"Crates are specified under the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[dependencies]\"), \" line in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cargo.toml\"), \", where versions are specified with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/semantic-versioningorSemantic-Versioning\",\n    \"title\": \"semantic-versioning|Semantic Versioning\"\n  }, \"[[semantic-versioning|Semantic Versioning]]\"), \".\"), mdx(\"h2\", {\n    \"id\": \"usage\"\n  }, \"Usage\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cargo build\"), \" - build a project\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cargo run\"), \" - build and run a project\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cargo check\"), \" - build a project without producing a binary to check for errors\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cargo build --release\"), \" - compile project with optimizations\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cargo update\"), \" - update packages\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cargo doc --open\"), \" - generate documentation for current Cargo project\")), mdx(\"h2\", {\n    \"id\": \"sources\"\n  }, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.rust-lang.org/book/ch01-03-hello-cargo.html\"\n  }, \"https://doc.rust-lang.org/book/ch01-03-hello-cargo.html\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"ac527191-d3b0-58e4-8e2a-64bbf406138c","fields":{"slug":"/docs/cargo","title":"Cargo"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"rust programming-language computer-science\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"ownership-rust\"\n  }, \"Ownership (Rust)\"), mdx(\"p\", null, \"In \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Rust\",\n    \"title\": \"Rust\"\n  }, \"[[Rust]]\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ownership\"), \" involves a set of rules regarding memory:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each value in Rust has a variable that's called its \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"owner\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"There can only be one owner at a time\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When the owner goes out of scope, the value will be dropped\")), mdx(\"h2\", {\n    \"id\": \"scope\"\n  }, \"Scope\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"{   // s is not valid here, it\\u2019s not yet declared\\n    let s = String::from(\\\"hello\\\");\\n    // s is valid from this point forward\\n\\n    // do stuff with s\\n}\\n// this scope is now over, and s is no longer valid\\n\")), mdx(\"p\", null, \"Rust works similarly to other languages in regards to scope:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When a variable comes \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"into scope\"), \", it is valid\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It remains valid until it goes \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"out of scope\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Deallocates resources at the end of the variable's lifetime\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"known as \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Resource Acquisition is Initialization (RAII)\"))))), mdx(\"p\", null, \"This deallocation is performed by a special Rust function, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"drop\"), \". Rust calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"drop\"), \" automatically for mutable types.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the author of such a type (ex. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"String\"), \") puts code in the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"drop\"), \" method to return the memory allocated by the variable\")), mdx(\"h2\", {\n    \"id\": \"move\"\n  }, \"Move\"), mdx(\"p\", null, \"Variables that implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Copy\"), \" trait have their values copied when interacting with the same data.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"let x = 5;\\nlet y = x;\\n\")), mdx(\"p\", null, \"Both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \" are variables bound to the value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"5\"), \". The two \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"5\"), \" values are both pushed onto the stack, since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"u32\"), \" implements the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Copy\"), \" trait. Therefore, both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \" can be used after this code. Here's a list of types that implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Copy\"), \":\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"all integer types\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"bool\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"all floating point types\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"char\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"tuples, if they only contain types that also implement \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Copy\"))), mdx(\"p\", null, \"However, for types that do not implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Copy\"), \" trait:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"let s1 = String::from(\\\"hello\\\");\\nlet s2 = s1;\\n\\n// This causes a compiler error!\\nprintln!(\\\"{}, world!\\\", s1);\\n\")), mdx(\"p\", null, \"Here, ownership is transferred from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"s1\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"s2\"), \", since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \"s do not implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Copy\"), \". Rust will never automatically create \\\"deep\\\" copies of data, so any \\\"automatic\\\" copying can be assumed to be inexpensive. To create a deep copy, we use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"clone\"), \" method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"let s1 = String::from(\\\"hello\\\");\\nlet s2 = s1.clone();\\n\\nprintln!(\\\"s1 = {}, s2 = {}\\\", s1, s2);\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"clone\"), \" is a visual indicator that arbitrary code is being executed, and that code may be expensive.\"), mdx(\"h2\", {\n    \"id\": \"benefits\"\n  }, \"Benefits\"), mdx(\"p\", null, \"Ownership solves several problems:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"keeping track of what parts of your code are using what data on the heap\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"minimizing the amount of duplicate data on the heap\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"cleaning up unused data on the heap to avoid running out of space\")), mdx(\"h2\", {\n    \"id\": \"sources\"\n  }, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html\"\n  }, \"https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"3def2448-1d24-57fb-80fa-6c13e6371361","fields":{"slug":"/docs/ownership-rust","title":"Ownership (Rust)"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"programming-languages game-engines frameworks computer-science rust\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"bevy\"\n  }, \"Bevy\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bevy\"), \" is an open source game engine built in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Rust\",\n    \"title\": \"Rust\"\n  }, \"[[Rust]]\"), \", focusing on an ECS system.\"), mdx(\"h2\", {\n    \"id\": \"sources\"\n  }, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://bevyengine.org\"\n  }, \"https://bevyengine.org\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"91e02224-c925-577e-b535-33f775c7b1f4","fields":{"slug":"/docs/bevy","title":"Bevy"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"computer-science web-dev javascript programming-languages\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"webassembly\"\n  }, \"WebAssembly\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"WebAssembly\"), \" (or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Wasm\"), \") is a low-level language in binary format that runs on the web with near-native performance.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for stack-based virtual machine\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"designed as a portable compilation format for several programming languages, especially low-level languages like C, C++, and \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Rust\",\n    \"title\": \"Rust\"\n  }, \"[[Rust]]\"), \"\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be run alongside \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/JavaScript\",\n    \"title\": \"JavaScript\"\n  }, \"[[JavaScript]]\"), \"\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be deployed to client or server web applications\")), mdx(\"h2\", {\n    \"id\": \"sources\"\n  }, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://webassembly.org\"\n  }, \"https://webassembly.org\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/WebAssembly\"\n  }, \"https://developer.mozilla.org/en-US/docs/WebAssembly\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"f7a5a51b-306e-5c72-80df-ddad46503baa","fields":{"slug":"/docs/webassembly","title":"WebAssembly"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"framework web-dev computer-science rust\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"yew\"\n  }, \"Yew\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Yew\"), \" is a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Rust\",\n    \"title\": \"Rust\"\n  }, \"[[Rust]]\"), \" framework for developing multi-threaded front-end web applications using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/WebAssembly\",\n    \"title\": \"WebAssembly\"\n  }, \"[[WebAssembly]]\"), \".\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"features component-based framework, similar to React\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"minimizes \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/DOM\",\n    \"title\": \"DOM\"\n  }, \"[[DOM]]\"), \" API calls to improve performance\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can operate alongside \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/JavaScript\",\n    \"title\": \"JavaScript\"\n  }, \"[[JavaScript]]\"), \" for use with npm packages\")), mdx(\"h2\", {\n    \"id\": \"sources\"\n  }, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://yew.rs\"\n  }, \"https://yew.rs\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"2c8b9527-85d3-5321-96fd-507e3be2ee56","fields":{"slug":"/docs/yew","title":"Yew"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"rust programming-languages computer-science\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"integer-types-rust\"\n  }, \"Integer Types (Rust)\"), mdx(\"p\", null, \"In \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Rust\",\n    \"title\": \"Rust\"\n  }, \"[[Rust]]\"), \", an integer is a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/data-types-rustordata-type\",\n    \"title\": \"data-types-rust|data type\"\n  }, \"[[data-types-rust|data type]]\"), \" representing a number without a fractional component. Rust supports integer types of explicit sizes and signed/unsigned variants.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Length\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Signed\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Unsigned\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"8-bit\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"i8\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"u8\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"16-bit\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"i16\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"u16\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"32-bit\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"i32\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"u32\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"64-bit\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"i64\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"u64\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"128-bit\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"i128\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"u128\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"arch\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"isize\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"usize\"))))), mdx(\"p\", null, \"Signed numbers are stored using two's complement representation.\"), mdx(\"p\", null, \"Each signed variant can store numbers from $-(2^{n-1})$ to $2^{n-1} - 1$ inclusive, where $n$ is the number of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/bit\",\n    \"title\": \"bit\"\n  }, \"[[bit]]\"), \"s that variant uses.\"), mdx(\"p\", null, \"Unsigned variants can store numbers from 0 to $2^n-1$.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isize\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"usize\"), \" types depend on the computer architecture, either 64-bit or 32-bit architecture.\"), mdx(\"p\", null, \"If unsure about which type to use, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i32\"), \" is a good place to start - although \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isize\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"usize\"), \" are good when indexing some sort of collection.\"), mdx(\"h2\", {\n    \"id\": \"integer-literals\"\n  }, \"Integer Literals\"), mdx(\"p\", null, \"Note that you can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_\"), \" in numbers literals to make them easier to read.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Number literals\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Example\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Decimal\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"98_222\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Hex\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"0xff\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Octal\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"0o77\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Binary\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"0b1111_0000\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Byte (\", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"u8\"), \" only)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"b'A'\"))))), mdx(\"h2\", {\n    \"id\": \"sources\"\n  }, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types\"\n  }, \"https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"8977e11d-c676-5711-a230-7ac3bbf6116c","fields":{"slug":"/docs/integer-types-rust","title":"Integer Types (Rust)"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"computer-science\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"integer-overflow\"\n  }, \"Integer Overflow\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Integer overflow\"), \" is a phenomenon that occurs when a variable's value is changed to a value outside its designated range.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for ex. in \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Rust\",\n    \"title\": \"Rust\"\n  }, \"[[Rust]]\"), \", integer overflow occurs when the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/integer-types-rustorinteger-type\",\n    \"title\": \"integer-types-rust|integer type\"\n  }, \"[[integer-types-rust|integer type]]\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"u8\"), \" variable's value goes outside its range of values between 0 and 255.\")), mdx(\"p\", null, \"In most programming languages, integer overflow causes \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"two's complement wrapping\"), \", where the value \\\"wraps around\\\" the minimum or maximum of the values the variable's type can hold.\"), mdx(\"h2\", {\n    \"id\": \"sources\"\n  }, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types\"\n  }, \"https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"872b631a-5734-5536-a139-20607c957169","fields":{"slug":"/docs/integer-overflow","title":"Integer Overflow"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"rust programming-languages computer-science\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"variables-rust\"\n  }, \"Variables (Rust)\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#variables-rust\"\n  }, \"Variables (Rust)\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#immutability\"\n  }, \"Immutability\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#constants\"\n  }, \"Constants\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#shadowing\"\n  }, \"Shadowing\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#sources\"\n  }, \"Sources\"))))), mdx(\"h2\", {\n    \"id\": \"immutability\"\n  }, \"Immutability\"), mdx(\"p\", null, \"Variables in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Rust\",\n    \"title\": \"Rust\"\n  }, \"[[Rust]]\"), \" are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"immutable\"), \" by default. You must \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"explicitly\"), \" declare a variable to be mutable.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"explicitly declaring mutability allows programmers to more often write code in ways that take advantage of Rust's safety and easy concurrency\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"compile-time errors when trying to change the value of immutable variables helps avoid bugs\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"let apples = 5;  // immutable\\nlet mut bananas = 5;  // mutable\\n\")), mdx(\"h2\", {\n    \"id\": \"constants\"\n  }, \"Constants\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Constants\"), \" are variables with values bound to a name that are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"never\"), \" allowed to change - they're always immutable.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be declared in any scope, including the global scope\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can only be set to a constant expression, not the result of a value that can only be computed at runtime\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\\n\")), mdx(\"p\", null, \"Constants are valid for the entire time a program runs within its declared scope.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"naming hardcoded values throughout a program is useful to convey meaning\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"helps reusability of values across a program\")), mdx(\"h2\", {\n    \"id\": \"shadowing\"\n  }, \"Shadowing\"), mdx(\"p\", null, \"We can \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"shadow\"), \" variables (even immutable ones!) by declaring the variable again, oftentimes with a different type. Shadowing is often used to convert a value from one type to another.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"shadowing effectively creates a new variable, just under the same name\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"lets us reuse variable names rather than forcing us to create two unique variables, causing confusion\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn main() {\\n    let x = 5;\\n\\n    let x = x + 1;\\n\\n    {\\n        let x = x * 2;\\n        println!(\\\"The value of x in the inner scope is: {}\\\", x);\\n    }\\n\\n    println!(\\\"The value of x is: {}\\\", x);\\n}\\n\")), mdx(\"p\", null, \"Output:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"The value of x in the inner scope is: 12\\nThe value of x is: 6\\n\")), mdx(\"h2\", {\n    \"id\": \"sources\"\n  }, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html\"\n  }, \"https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"cb250aa4-7bfe-56ce-ae7b-8147fa4cdcc2","fields":{"slug":"/docs/variables-rust","title":"Variables (Rust)"}}}]},"fields":{"slug":"/docs/rust","title":"Rust"}}},"pageContext":{"id":"bff7d1a4-3518-5a12-940a-c125c880e96e"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}