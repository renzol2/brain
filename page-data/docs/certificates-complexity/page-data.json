{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/docs/certificates-complexity","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"cs-374 computer-science computer science p-vs-np algorithms reduction theory\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"certificates-complexity\"\n  }, \"Certificates (complexity)\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Certificates\"), \" are proofs that a given instance is \\\"good\\\". In \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/decision-problems\",\n    \"title\": \"decision-problems\"\n  }, \"[[decision-problems]]\"), \", a certificate is a particular input that solves the problem.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"CircuitSAT\"), \" (\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/circuit-satisfiability\",\n    \"title\": \"circuit-satisfiability\"\n  }, \"[[circuit-satisfiability]]\"), \") is a set of inputs that turns on the light bulb\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SAT\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"3SAT\"), \" is a satisfying assignment\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MaxIndSet\"), \" is a large independent set\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"cs-374 computer-science computer science p-vs-np algorithms decision-problems theory\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"decision-problems\"\n  }, \"Decision Problems\"), mdx(\"p\", null, \"A decision problem is a problem whose output is a single boolean value, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Yes\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"No\"), \".\"), mdx(\"p\", null, \"The input size of decision problems can stretch to an infinite set, but the output is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"always\"), \" a boolean value.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"5b27def8-2f70-5cc0-8559-add97e4cd429","fields":{"slug":"/docs/decision-problems","title":"Decision Problems"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"cs-374 computer-science computer science p-vs-np algorithms circuit-satisfiability np-complete decision-problems theory\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"circuit-satisfiability\"\n  }, \"Circuit Satisfiability\"), mdx(\"p\", null, \"Also known as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CircuitSAT\"), \". Circuit satisfiability is one of many \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/decision-problems\",\n    \"title\": \"decision-problems\"\n  }, \"[[decision-problems]]\"), \".\"), mdx(\"p\", null, \"Circuit satisfiability: Given a boolean circuit, is there a set of inputs that makes the circuit output \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"True\"), \", or conversely, whether the circuit \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"always\"), \" outputs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"False\"), \".\"), mdx(\"p\", null, \"For any particular input setting of a given circuit, we can calculate the output of the circuit in linear time using depth-first-search.\"), mdx(\"p\", null, \"However, to test \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"all\"), \" inputs for a given circuit (and therefore solve \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CircuitSAT\"), \"), nobody knows how to solve it faster than brute-forcing all $2^n$ possible inputs.\"), mdx(\"p\", null, \"However, no one has formally proven that we \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"can't\"), \" beat brute force, so there may be some clever, undiscovered algorithm.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"5b18629d-864c-50e4-932a-f0941b3902c2","fields":{"slug":"/docs/circuit-satisfiability","title":"Circuit Satisfiability"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"cs-374 computer-science computer science p-vs-np algorithms reduction theory\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"reduction-complexity\"\n  }, \"Reduction (complexity)\"), mdx(\"p\", null, \"Given two problems A and B (ex. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/decision-problems\",\n    \"title\": \"decision-problems\"\n  }, \"[[decision-problems]]\"), \"), \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"reduction\"), \" is describing an algorithm to solve problem A under the assumption that an algorithm for problem B already exists.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Intuitively, if you know some algorithm to solve problem B, and you can convert problem A to problem B, then you can solve problem A using the same algorithm.\")), mdx(\"p\", null, \"This reduction process is often used to prove problems are NP-hard (see: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/p-vs-np\",\n    \"title\": \"p-vs-np\"\n  }, \"[[p-vs-np]]\"), \").\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"To prove that problem \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"A\"), \" is NP-hard, reduce a known NP-hard problem to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"A\"), \".\")), mdx(\"h2\", {\n    \"id\": \"general-outline-of-reduction\"\n  }, \"General Outline of Reduction\"), mdx(\"p\", null, \"All polynomial-time reductions, including NP-hardness proofs, follow the same general outline. To reduce problem \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"X\"), \" to problem \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Y\"), \" in polynomial time, we need to do three things:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Describe a polynomial-time algorithm to transform an \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"arbitrary\"), \" instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"X\"), \" into a \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"special\"), \" instance \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Y\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Prove that if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is a \\\"good\\\" instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"X\"), \", then \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" is a \\\"good\\\" instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Y\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Prove that if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" is a \\\"good\\\" instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Y\"), \", then \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is a \\\"good\\\" instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"X\"), \" (This is usually the part that causes the most trouble).\")), mdx(\"p\", null, \"To describe the algorithm that reduces \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"X\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Y\"), \", we actually need to design \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"three\"), \" algorithms, one for each of the following tasks (corresponding to the above steps). These steps involve the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"certificates\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/certificates-complexity\",\n    \"title\": \"certificates-complexity\"\n  }, \"[[certificates-complexity]]\"), \" for each problem:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Transform an arbitrary instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"X\"), \" into a special instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Y\"), \" in polynomial time\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Transform an arbitrary certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" into a certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \", and\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Transform an arbitrary certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" into a certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"))), mdx(\"p\", null, \"Here, the 2nd and 3rd steps refer to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"input\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"output\"), \" of the first algorithm.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"5e0f6027-2c3d-5fe3-b5ab-0f34304831a8","fields":{"slug":"/docs/reduction-complexity","title":"Reduction (complexity)"}}}]},"fields":{"slug":"/docs/certificates-complexity","title":"Certificates (complexity)"}}},"pageContext":{"id":"b2c3c9f7-270f-51e4-b361-c737d36b7327"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}