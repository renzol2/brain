{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/docs/decision-problems","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"cs-374 computer-science computer science p-vs-np algorithms decision-problems theory\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"decision-problems\"\n  }, \"Decision Problems\"), mdx(\"p\", null, \"A decision problem is a problem whose output is a single boolean value, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Yes\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"No\"), \".\"), mdx(\"p\", null, \"The input size of decision problems can stretch to an infinite set, but the output is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"always\"), \" a boolean value.\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"cs-374 computer-science computer science p-vs-np algorithms theory\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"p-vs-np\"\n  }, \"P vs. NP\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If a problem is easy to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"check\"), \" the solution to, is it easy to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"find\"), \" the solution? - Jade, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=EHp4FPyajKQ\"\n  }, \"Up and Atom\"))), mdx(\"h2\", {\n    \"id\": \"decision-problems\"\n  }, \"Decision Problems\"), mdx(\"p\", null, \"A decision problem is a problem whose output is a single boolean value, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Yes\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"No\"), \". See: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/decision-problems\",\n    \"title\": \"decision-problems\"\n  }, \"[[decision-problems]]\"), \".\"), mdx(\"p\", null, \"There are 3 classes of decision problems:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"P\"), \" is the set of decision problems that can be solved in polynomial time. Intuitively, P is the set of problems that can be \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"solved quickly\"), \".\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ex. Bipartite Matching\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"NP\"), \" is the set of decision problems with the following property:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the answer is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Yes\"), \", then there is a \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"proof\"), \" of this fact that can be checked in polynomial time.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Intuitively, NP is the set of decision problems where we can verify a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Yes\"), \" answer quickly if we have the solution in front of us.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Abbreviation of \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"N\"), \"ondeterministic \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"P\"), \"olynomial-time\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"co-NP\"), \" is essentially the opposite of NP. If the answer to a problem in co-NP is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"No\"), \", then there is a proof of this fact that can be checked in polynomial time.\")), mdx(\"p\", null, \"A more digestible breakdown provided by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=n0zd5hcOSQI\"\n  }, \"Georgia Tech\"), \":\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"P\"), \": Problems \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"solvable\"), \" in polynomial time\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"NP\"), \": Problems \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"verifiable\"), \" in polynomial time\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Over time, some NP problems have been found to be in P.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"NP-complete\"), \": Hardest problems in NP.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"No NP-complete problems have been found to be in P.\")))), mdx(\"p\", null, \"Some properties of these complexity classes:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Every decision problem in P is also in NP.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If a problem is in P, we can verify \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Yes\"), \" answers in polynomial time from scratch, meaning it is also in NP.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Every problem in P is also in co-NP.\")), mdx(\"h2\", {\n    \"id\": \"np-hard-np-easy-and-np-complete\"\n  }, \"NP-hard, NP-easy, and NP-complete\"), mdx(\"p\", null, \"A problem \\u03A0 is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NP-hard\"), \" if a polynomial time algorithm for \\u03A0 would imply a polynomial time algorithm for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"every problem in NP\"), \". In other word:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"\\u03A0 is NP-hard <-> If \\u03A0 can be solved in polynomial time, then P = NP\\n\")), mdx(\"p\", null, \"Intuitively, if we could solve one particular NP-hard problem quickly, then we could quickly solve \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \" problem whose solution is easy to understand, using the solution to that one special problem as a subroutine.\"), mdx(\"p\", null, \"NP-hard problems are at least as hard as every problem in NP.\"), mdx(\"p\", null, \"Problems are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NP-complete\"), \" if they are both NP-hard and an element of NP (or \\\"NP-easy\\\").\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A polynomial-time algorithm for even one NP-complete problem would immediately imply a polynomial time algorithm for \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"every\"), \" NP-complete problem\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Seems incredibly unlikely, since thousands of problems have been shown to be NP-complete\")), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"540px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/brain/static/1ee6d3fb8bd97270be4f13d03e1d7d9b/07484/P-vs-NP-vs-coNP-vs-NP-hard-vs-NP-complete.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"52.142857142857146%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABWElEQVQoz31RXW+CQBDk//dv9LFJ7UuTmjat8dumMfjVihyKchwciCKHWLg7umBirGmdh81tNrO3M6PkvyFlUcOIqVO9j5aqsexPkRdsilF+CeW8yUrAQ19ZqkWbQ705RD2DDGbzXIr8CjkMQ8dxKKUxY7ppPXQ6j4NWdfiBgsPnfCXEVTLGONrtoFoWbrefu4NqZ/Ry17u/ebqNYlaeLf8lu65LbNvzAxsja9HcR1M8b5tGV/eWqocWW0LjzXofOixw4g0vVSilScXKJEkIsdMs+5o0jFkdzerfew1jA0ZCCmDiyLd2FAW2uXVTkV0axkAtMuq1ynun0mpUqGtmXJy2/6FZghWcn/o0TU1zMRmr67V/Fp48JiVLnNYpSRLXXt/GozHSdU3TPEp932cspq4L5hNCjhUAQYCd4AsAbIV0irMPSZKlIJZDyLK4o0ibcy7OIMUl4PMfIhc0p5xX34UAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"More of what we think the world looks like\",\n    \"title\": \"More of what we think the world looks like\",\n    \"src\": \"/brain/static/1ee6d3fb8bd97270be4f13d03e1d7d9b/07484/P-vs-NP-vs-coNP-vs-NP-hard-vs-NP-complete.png\",\n    \"srcSet\": [\"/brain/static/1ee6d3fb8bd97270be4f13d03e1d7d9b/0d3e1/P-vs-NP-vs-coNP-vs-NP-hard-vs-NP-complete.png 140w\", \"/brain/static/1ee6d3fb8bd97270be4f13d03e1d7d9b/6b1e2/P-vs-NP-vs-coNP-vs-NP-hard-vs-NP-complete.png 281w\", \"/brain/static/1ee6d3fb8bd97270be4f13d03e1d7d9b/07484/P-vs-NP-vs-coNP-vs-NP-hard-vs-NP-complete.png 540w\"],\n    \"sizes\": \"(max-width: 540px) 100vw, 540px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"h2\", {\n    \"id\": \"p--np\"\n  }, \"P != NP\"), mdx(\"p\", null, \"Perhaps the single most important unanswered question in theoretical CS, or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"science\"), \" in general, is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"P != NP\"), \".\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Intuitively: are the complexity classes P and NP actually different?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We generally accept P != NP as a \\\"law of nature\\\": something strongly supported by evidence but having no mathematical proof\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"No one has figured out to prove P != NP. There is a $1,000,000 reward for the solution by the Clay Mathematics Institute, though!\")), mdx(\"p\", null, \"We also don't know exactly if NP != co-NP.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Intuitively: even if we can verify every \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Yes\"), \" answer quickly, there's no reason to believe we can verify \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"No\"), \" answers quickly.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Generally believed that NP != co-NP, but no concrete proof\")), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"525px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/brain/static/190e006988453560178a9f3ff6e6bee8/52211/P-vs-NP-vs-coNP.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"50%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA9ElEQVQoz51R226FIBD0/39Kf8HERk/iFTwGRQOCisbL6VTSNG2jTTpPw7LD7CzO6zuO47g5/oDzuySE4JzP8wy+77tSqmmaaZruxNYErZTSoiiCIHieyPOcEAKyrusfYillzVhZUiFkGIZVVY3D0HUdY8zOcjc2nieUgrRtC884jpdlgQzOl2MfJ5DQZkbIKIoejygMoyzLoLS2xycuFwYYY3zfd13X87w0Tbdtu9w2Ir0FQZJmz7JsOYctKlIKSkiRFxgEHJW6bpCla9HCrbljfdIkYaw+Lxqtdd+rcRzNZIYB+/oAfkH2SvW91qD6S/xvvAPA6kDn8of0CQAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"What we think the world looks like.\",\n    \"title\": \"What we think the world looks like.\",\n    \"src\": \"/brain/static/190e006988453560178a9f3ff6e6bee8/52211/P-vs-NP-vs-coNP.png\",\n    \"srcSet\": [\"/brain/static/190e006988453560178a9f3ff6e6bee8/0d3e1/P-vs-NP-vs-coNP.png 140w\", \"/brain/static/190e006988453560178a9f3ff6e6bee8/6b1e2/P-vs-NP-vs-coNP.png 281w\", \"/brain/static/190e006988453560178a9f3ff6e6bee8/52211/P-vs-NP-vs-coNP.png 525w\"],\n    \"sizes\": \"(max-width: 525px) 100vw, 525px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"h2\", {\n    \"id\": \"reduction\"\n  }, \"Reduction\"), mdx(\"p\", null, \"Problems are proven to be in particular complexity classes through the process of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"reduction\"), \" (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/reduction-complexity\",\n    \"title\": \"reduction-complexity\"\n  }, \"[[reduction-complexity]]\"), \"), i.e. using an algorithm that solves problem A to solve problem B and therefore proving that they are within the same complexity class.\"), mdx(\"p\", null, \"Over time, many NP problems have been proven to be in P. However, no NP-complete problems have been proven to be in P yet.\"), mdx(\"h2\", {\n    \"id\": \"the-cook-levin-theorem\"\n  }, \"The Cook-Levin Theorem\"), mdx(\"p\", null, \"Circuit satisfiability (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/circuit-satisfiability\",\n    \"title\": \"circuit-satisfiability\"\n  }, \"[[circuit-satisfiability]]\"), \") is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NP-hard\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"8f751d65-b4ff-5d86-a5f4-02ec087afa43","fields":{"slug":"/docs/p-vs-np","title":"P vs. NP"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"cs-374 computer-science computer science p-vs-np algorithms circuit-satisfiability np-complete decision-problems theory\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"circuit-satisfiability\"\n  }, \"Circuit Satisfiability\"), mdx(\"p\", null, \"Also known as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CircuitSAT\"), \". Circuit satisfiability is one of many \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/decision-problems\",\n    \"title\": \"decision-problems\"\n  }, \"[[decision-problems]]\"), \".\"), mdx(\"p\", null, \"Circuit satisfiability: Given a boolean circuit, is there a set of inputs that makes the circuit output \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"True\"), \", or conversely, whether the circuit \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"always\"), \" outputs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"False\"), \".\"), mdx(\"p\", null, \"For any particular input setting of a given circuit, we can calculate the output of the circuit in linear time using depth-first-search.\"), mdx(\"p\", null, \"However, to test \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"all\"), \" inputs for a given circuit (and therefore solve \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CircuitSAT\"), \"), nobody knows how to solve it faster than brute-forcing all $2^n$ possible inputs.\"), mdx(\"p\", null, \"However, no one has formally proven that we \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"can't\"), \" beat brute force, so there may be some clever, undiscovered algorithm.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"5b18629d-864c-50e4-932a-f0941b3902c2","fields":{"slug":"/docs/circuit-satisfiability","title":"Circuit Satisfiability"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"cs-374 computer-science computer science p-vs-np algorithms reduction theory\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"reduction-complexity\"\n  }, \"Reduction (complexity)\"), mdx(\"p\", null, \"Given two problems A and B (ex. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/decision-problems\",\n    \"title\": \"decision-problems\"\n  }, \"[[decision-problems]]\"), \"), \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"reduction\"), \" is describing an algorithm to solve problem A under the assumption that an algorithm for problem B already exists.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Intuitively, if you know some algorithm to solve problem B, and you can convert problem A to problem B, then you can solve problem A using the same algorithm.\")), mdx(\"p\", null, \"This reduction process is often used to prove problems are NP-hard (see: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/p-vs-np\",\n    \"title\": \"p-vs-np\"\n  }, \"[[p-vs-np]]\"), \").\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"To prove that problem \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"A\"), \" is NP-hard, reduce a known NP-hard problem to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"A\"), \".\")), mdx(\"h2\", {\n    \"id\": \"general-outline-of-reduction\"\n  }, \"General Outline of Reduction\"), mdx(\"p\", null, \"All polynomial-time reductions, including NP-hardness proofs, follow the same general outline. To reduce problem \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"X\"), \" to problem \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Y\"), \" in polynomial time, we need to do three things:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Describe a polynomial-time algorithm to transform an \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"arbitrary\"), \" instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"X\"), \" into a \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"special\"), \" instance \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Y\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Prove that if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is a \\\"good\\\" instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"X\"), \", then \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" is a \\\"good\\\" instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Y\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Prove that if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" is a \\\"good\\\" instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Y\"), \", then \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is a \\\"good\\\" instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"X\"), \" (This is usually the part that causes the most trouble).\")), mdx(\"p\", null, \"To describe the algorithm that reduces \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"X\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Y\"), \", we actually need to design \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"three\"), \" algorithms, one for each of the following tasks (corresponding to the above steps). These steps involve the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"certificates\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/certificates-complexity\",\n    \"title\": \"certificates-complexity\"\n  }, \"[[certificates-complexity]]\"), \" for each problem:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Transform an arbitrary instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"X\"), \" into a special instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Y\"), \" in polynomial time\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Transform an arbitrary certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" into a certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \", and\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Transform an arbitrary certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" into a certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"))), mdx(\"p\", null, \"Here, the 2nd and 3rd steps refer to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"input\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"output\"), \" of the first algorithm.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"5e0f6027-2c3d-5fe3-b5ab-0f34304831a8","fields":{"slug":"/docs/reduction-complexity","title":"Reduction (complexity)"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"tags\": \"cs-374 computer-science computer science p-vs-np algorithms reduction theory\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"certificates-complexity\"\n  }, \"Certificates (complexity)\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Certificates\"), \" are proofs that a given instance is \\\"good\\\". In \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/decision-problems\",\n    \"title\": \"decision-problems\"\n  }, \"[[decision-problems]]\"), \", a certificate is a particular input that solves the problem.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"CircuitSAT\"), \" (\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/circuit-satisfiability\",\n    \"title\": \"circuit-satisfiability\"\n  }, \"[[circuit-satisfiability]]\"), \") is a set of inputs that turns on the light bulb\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SAT\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"3SAT\"), \" is a satisfying assignment\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A certificate for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MaxIndSet\"), \" is a large independent set\")), mdx(\"p\", null, \"For problems that are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"in NP\"), \" (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/p-vs-np\",\n    \"title\": \"p-vs-np\"\n  }, \"[[p-vs-np]]\"), \"), if the answer is \\\"Yes\\\", then\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"a polynomial-sized certificate can be provided which proves that the answer is \\\"Yes\\\", and\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"the validity of this certificate can be checked in polynomial time.\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"b2c3c9f7-270f-51e4-b361-c737d36b7327","fields":{"slug":"/docs/certificates-complexity","title":"Certificates (complexity)"}}}]},"fields":{"slug":"/docs/decision-problems","title":"Decision Problems"}}},"pageContext":{"id":"5b27def8-2f70-5cc0-8559-add97e4cd429"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}